<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on T.Muroiのblog</title>
    <link>http://blog.dtdweb.com/tags/android/</link>
    <description>Recent content in Android on T.Muroiのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 08 Mar 2017 23:39:05 +0900</lastBuildDate>
    <atom:link href="http://blog.dtdweb.com/tags/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[Android]地図メモというアプリをリリースしました</title>
      <link>http://blog.dtdweb.com/post/2017/03/android-mapmemo/</link>
      <pubDate>Wed, 08 Mar 2017 23:39:05 +0900</pubDate>
      
      <guid>http://blog.dtdweb.com/post/2017/03/android-mapmemo/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://blog.dtdweb.com/images/post/2017/03/ss_08_ss1.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;実際にリリースしたのは昨年なんですけどね。&lt;/p&gt;

&lt;p&gt;いい加減このブログでも記事を残しておきたいなと思い書いてみました。&lt;/p&gt;

&lt;p&gt;実際に作ったアプリは下記URLから落とせますので、よかったらDLしてください。お願いします！！&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://play.google.com/store/apps/details?id=com.dtdweb.mapmemo&#34;&gt;https://play.google.com/store/apps/details?id=com.dtdweb.mapmemo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;アプリのコンセプトとしては、地図に手軽にメモを残したい。複雑な機能はいらないからシンプルにメモだけを残しておきたい。&lt;/p&gt;

&lt;p&gt;そんな感じのアプリがほしいなと考え、アプリの企画と設計なんかを1ヶ月弱くらいで考え、開発は1週間くらいで何とかリリースまで持っていきました。&lt;/p&gt;

&lt;p&gt;個人で作るアプリは途中で飽きてリリースまで行かないというのをどこかで聞いた事があるので、とりあえず2日以上の開発日数がかかるアプリは作らない。
どうしても工数がかかる場合はフェーズをわけてアップデートをしてこうというルールを決めておき、何とかリリースまで持っていけました。&lt;/p&gt;

&lt;p&gt;※実際は1週間かかったけど、仕事終わりの夜とか土日の手が空いた時間を使ってだから、一応セーフかなと自分の中では思ってます。&lt;/p&gt;

&lt;h2 id=&#34;作ってみて良かったこと:388e88fa766f08c97310badd066c987e&#34;&gt;作ってみて良かったこと&lt;/h2&gt;

&lt;p&gt;個人で開発する上で重要なのは、新しい技術取得やライブラリの使い方ではなく、一番はモチベーション維持だという事がわかりました。&lt;/p&gt;

&lt;p&gt;シンプルに、シンプルにと考えつつも途中で妄想が膨らみ、こんな機能が合ったら便利じゃね。とか考えて色々と手が止まる事がありました。&lt;/p&gt;

&lt;p&gt;逆に、この機能を作った所で誰が使うんだろう…、そもそもこのアプリを使ってくれる人はいるのか？なんてネガティブな事も考えたり。&lt;/p&gt;

&lt;p&gt;とりあえずEvernoteに最初の仕様を書いておき、途中の妄想も次フェーズとかでやれたらやろうとか考えておいてEvernoteにメモして終わり。最初の機能だけに目を向ける！という姿勢を作っておいたのは本当に良かったなと思いました。&lt;/p&gt;

&lt;h2 id=&#34;今後について:388e88fa766f08c97310badd066c987e&#34;&gt;今後について&lt;/h2&gt;

&lt;p&gt;今後は、マップ画面での検索機能や、その他ちょくちょく機能改修しつつ、デザイン周りのブラッシュアップを進めていけたらなと思います。&lt;/p&gt;

&lt;p&gt;というか本当にデザインは力を入れていきたい&amp;hellip;。外注するまででもないので、せっかくだから自分である程度デザインもやってみたいと思ってはいるのですが。&lt;/p&gt;

&lt;p&gt;とりあえずデザインガイドラインを再度確認して、まずは素材以外での修正が可能な箇所のブラッシュアップを進めていきたい。&lt;/p&gt;

&lt;p&gt;後は、業務ではなかなか試せないようなライブラリとかも積極的に取り入れたりしてみたいなと思ってます。&lt;/p&gt;

&lt;p&gt;それから、次に開発するアプリこそKotlinで開発したい。ほんといえばこのアプリもKotlinで開発したかったのですけど、途中開発をしている際にモチベーションの低下を恐れ、とりあえず今回は出す事優先にしてしまいました。。&lt;/p&gt;

&lt;p&gt;出す事が目標だったので次回こそは新しい事に挑戦しながらってみよう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AndroidのFragmentでActivityのToolbarを利用する</title>
      <link>http://blog.dtdweb.com/post/2016/10/android-fragment-toolbar/</link>
      <pubDate>Sun, 16 Oct 2016 10:00:00 +0900</pubDate>
      
      <guid>http://blog.dtdweb.com/post/2016/10/android-fragment-toolbar/</guid>
      <description>&lt;p&gt;Activityは1つでFragmentは複数あり、1つのActivityの中でView切替をしてます。&lt;/p&gt;

&lt;p&gt;その中で、あるFragmentでは検索バーを出したいなと思いToolbarを呼び出してみたのですが、inflateMenuした後にFragment切替をするとそのままMenuが残ってしまい。&lt;/p&gt;

&lt;p&gt;Fragmentを切り替えたときは検索バーを消したいなと思い下記の対応で消してみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FragmentのonCreateView内で検索バーを追加&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                         Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_memo_list, container, false);

    Toolbar toolbar = (Toolbar) getActivity().findViewById(R.id.toolbar);
    toolbar.inflateMenu(R.menu.search);

    SearchView searchView = (SearchView) toolbar.getMenu().findItem(R.id.menu_search).getActionView();
    searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
        @Override
        public boolean onQueryTextSubmit(String query) {
            return false;
        }

        @Override
        public boolean onQueryTextChange(String newText) {
            return false;
        }
    });

    return view;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getActivity().findViewByIdでActivityのViewからToolbarのインスタンスを取得し追加&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FragmentのonDestroyView内で検索バーをクリアする&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void onDestroyView() {
    Toolbar toolbar = (Toolbar)getActivity().findViewById(R.id.toolbar);
    toolbar.getMenu().clear();

    super.onDestroyView();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Androidのwebviewで画像が正しく表示されない時の対処法</title>
      <link>http://blog.dtdweb.com/2015/12/23/android-mixed-content-mode/</link>
      <pubDate>Wed, 23 Dec 2015 10:09:01 +0000</pubDate>
      
      <guid>http://blog.dtdweb.com/2015/12/23/android-mixed-content-mode/</guid>
      <description>

&lt;p&gt;最近Androidアプリを開発している時に発生したのですが、webviewを表示する画面で一部画像が正しく表示されない問題が発生しました。&lt;/p&gt;

&lt;p&gt;何でだろうとエラーログを確認した所、下記の様なエラーが&amp;#8230;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[INFO:CONSOLE(0)] &amp;quot;Mixed Content: The page at &#39;https://***.com&#39; was loaded over HTTPS, but requested an insecure image &#39;http://***.com/img/hoge.png&#39;. This request has been blocked; the content must be served over HTTPS.&amp;quot;, source: https://***.com (0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうもhttpsのページ内でURLがhttpの画像を表示しようとした所、httpへのリクエストが安全ではないとの理由ブロックされていた様でした。&lt;/p&gt;

&lt;p&gt;今までこんな事はなかったのに…。&lt;/p&gt;

&lt;p&gt;色々と原因を調べた所、Android L(API Level21)から一部仕様の変更があった様でした。&lt;/p&gt;

&lt;p&gt;Android Lから、httpとhttpsの混在しているページをwebviewで表示しようとするとブロックする様にデフォルトの設定が反対になったようでして…。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#39;http://developer.android.com/intl/ja/reference/android/webkit/WebSettings.html#setMixedContentMode%28int%29&#39; target=&#39;_blank&#39;&gt;WebSettings | Android Developers #setMixedContentMode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この設定が変わっていたため画像も表示されませんでした。&lt;/p&gt;

&lt;p&gt;確かにセキュリティの観点から見ると対応として正しいと思うのですが、こんな罠が…。&lt;/p&gt;

&lt;h2 id=&#34;対応方法:5ecf30485b06f63d40a737361a0ef539&#34;&gt;対応方法&lt;/h2&gt;

&lt;p&gt;対応方法としては、セキュリティの理由から変更されているので、可能ならwebページ側のコンテンツを直すのが一番良さそうですね。&lt;/p&gt;

&lt;p&gt;※ただ自分で管理しているページなら対応出来るかもしれないけど、すぐ出来ない場合もありますよね…。&lt;/p&gt;

&lt;p&gt;アプリ側で対応を行う場合は、下記の様にwebviewの設定を変更する事で混在コンテンツのページも正常に表示される様になりました。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/dtdweb/d55fd9066b30df9cfd51.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;とりあえず仕事でもアプリ開発しているのだし、もう少し公式ブログやドキュメントとか追ってないとなーと反省しました..(^_^;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Android]XmlPullParserException: Unexpected tokenが発生した時の対処方法</title>
      <link>http://blog.dtdweb.com/2015/06/17/android-xmlpullparserexception-unexpected-token/</link>
      <pubDate>Tue, 16 Jun 2015 23:33:03 +0000</pubDate>
      
      <guid>http://blog.dtdweb.com/2015/06/17/android-xmlpullparserexception-unexpected-token/</guid>
      <description>

&lt;p&gt;Androidアプリ開発の際、リソースファイルやHttp経由で取得したUTF-8なxmlファイルをStringReaderで読み込むと、下記の様なエラーが発生する場合、読み込んだファイルの先頭にBOMが付いている可能性があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XmlPullParserException
org.xmlpull.v1.XmlPullParserException: Unexpected token (position:TEXT ?@1:2 in java.io.StringReader@***)
     at org.kxml2.io.KXmlParser.next(KXmlParser.java:432)
     at org.kxml2.io.KXmlParser.next(KXmlParser.java:313)
・
・
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;解決方法:7d33596006e6af95dde9f6df20e5121e&#34;&gt;解決方法&lt;/h2&gt;

&lt;p&gt;StringReaderで読み込む前にBOM付きかチェックして除去することで回避できました。&lt;/p&gt;

&lt;h3 id=&#34;サンプルコード:7d33596006e6af95dde9f6df20e5121e&#34;&gt;サンプルコード&lt;/h3&gt;

&lt;script src=&#34;https://gist.github.com/dtdweb/b0fe8d1c1b7580fb0345.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>[Android]URLConnectionでリダイレクトにも対応してみた</title>
      <link>http://blog.dtdweb.com/2015/06/16/url-connection-redirect/</link>
      <pubDate>Mon, 15 Jun 2015 23:52:57 +0000</pubDate>
      
      <guid>http://blog.dtdweb.com/2015/06/16/url-connection-redirect/</guid>
      <description>&lt;p&gt;org.apache.httpパッケージとAndroidHttpClientクラスがAndroid5.1(API Level 22)から非推奨になりましたね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/about/versions/android-5.1.html&#34; target=&#34;_blank&#34;&gt;Android 5.1 APIs | Android Developers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これまでHttpClientで実装していたアプリはURLConnectionクラスを利用・変更しましょうとの事で。&lt;/p&gt;

&lt;p&gt;それで今回はURLConnectionの実装に切り替えた際に、リダイレクト処理でうまく動作しなかったので、リダイレクトに対応したサンプルメソッドを作ってみました。&lt;/p&gt;

&lt;p&gt;HttpClientなら特に30系のステータスコードでも意識する必要なかったんですけど、ちょっと面倒ですね。&lt;/p&gt;

&lt;p&gt;ということで30系でも動作するように対応したサンプルメソッド&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/dtdweb/13e25365a827df07ce07.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;一度レスポンスコードを受け取り、20x系なら正常処理、30x系の場合は再度connクラスを再生成して対応しました。&lt;/p&gt;

&lt;p&gt;にしても、IO系クラス扱うのも少し苦手だ&amp;hellip;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Android]FragmentでMapViewを使った時の問題と解決策</title>
      <link>http://blog.dtdweb.com/2015/03/31/fragment-mapview-v2/</link>
      <pubDate>Mon, 30 Mar 2015 15:18:57 +0000</pubDate>
      
      <guid>http://blog.dtdweb.com/2015/03/31/fragment-mapview-v2/</guid>
      <description>

&lt;p&gt;久しぶりの更新です。最近ぜんぜん更新しないまま、だいぶ経ってしまいました。&lt;/p&gt;

&lt;p&gt;書きたい事は結構あるのに、忙しいとかを理由にサボってしまい…。&lt;/p&gt;

&lt;p&gt;またちょいちょい更新していこう。&lt;/p&gt;

&lt;p&gt;今回は、AndroidのMapViewを使ったアプリ開発の際に起きた問題とその解決策について、自分なりですが対応した方法を書いてみました。&lt;/p&gt;

&lt;p&gt;問題の方は、Map表示のMapViewをロードする際に画面が黒や白っぽく一瞬チラッと表示される現象があり、動作上は特に問題ないのですが、ちょっと動きとして何か気持ち悪いなと思ったので対応出来ないかと調べて対応してみました。&lt;/p&gt;

&lt;p&gt;ちなみに発生する端末は、最近の端末では発生せず、API Level14/4.0系と、現在より3年くらい前の機種で現象が起きていたので、単純に端末のスペックが問題なんだろうなとも思ってます。&lt;/p&gt;

&lt;p&gt;実際に対応した方法ですが、Fragmentで利用するMapViewの上に透過したレイアウトを重ねておく事で、下に表示されたマップの描画処理を抑える事ができ、画面の黒表示などを消す事が出来ました。&lt;/p&gt;

&lt;p&gt;※ただ、今回の現象を抑える事は出来ましたが、これが本当に解決策として正しいのかかなり怪しいので、詳しく知っている方がいればぜひ教えて頂きたいです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;レイアウトファイル: (fragment_map_sample.xml)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;LinearLayout
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:orientation=&amp;quot;vertical&amp;quot;
    tools:context=&amp;quot;com.dtdweb.mapfragmentsample.fragments.MapSampleFragment&amp;quot;&amp;gt;

    &amp;lt;FrameLayout
        android:layout_width=&amp;quot;fill_parent&amp;quot;
        android:layout_height=&amp;quot;fill_parent&amp;quot;&amp;gt;

        &amp;lt;com.google.android.gms.maps.MapView
            android:id=&amp;quot;@+id/mapview&amp;quot;
            android:layout_width=&amp;quot;fill_parent&amp;quot;
            android:layout_height=&amp;quot;fill_parent&amp;quot; /&amp;gt;

        &amp;lt;TextView
            android:id=&amp;quot;@+id/transparent_layout&amp;quot;
            android:layout_width=&amp;quot;fill_parent&amp;quot;
            android:layout_height=&amp;quot;fill_parent&amp;quot;
            android:background=&amp;quot;@drawable/translucent_background&amp;quot; /&amp;gt;

    &amp;lt;/FrameLayout&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;完成画面:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.dtdweb.com/images/wp-content/uploads/2015/03/20150331_fragment_mapview_sample.png&#34; alt=&#34;20150331_fragment_mapview_sample&#34; width=&#34;180&#34; height=&#34;300&#34; class=&#34;alignnone size-medium&#34; /&gt;&lt;/p&gt;

&lt;p&gt;画面の通り見かけ上は変わらず、またFragmentを切り替えた際も画面のチラつきを抑える事が出来ました。&lt;/p&gt;

&lt;p&gt;(ActivityやFragmentのソースコードについてはgitにアップしております)&lt;/p&gt;

&lt;p&gt;もうちょっと調べて、他に方法がないか調べてみる必要がありそうです…。&lt;/p&gt;

&lt;h2 id=&#34;参考:d493a555f3b789dfb12d50a1710f0197&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;サンプルで使っているMapViewはGoogle Map API v2を使用&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/maps/documentation/android/?hl=ja&#34; title=&#34;https://developers.google.com/maps/documentation/android/?hl=ja&#34; target=&#34;_blank&#34;&gt;Google Maps Android API  &amp;nbsp;|&amp;nbsp; Google Developers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;サンプルのソースコードは下記リポジトリに追加しております。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/dtdweb/android/tree/master/Fragment-MapViewSample/MapFragmentSample&#34; title=&#34;https://github.com/dtdweb/android/tree/master/Fragment-MapViewSample/MapFragmentSample&#34; target=&#34;_blank&#34;&gt;android/Fragment-MapViewSample/MapFragmentSample&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Android]GPSの使い方、プロバイダのメリット・デメリットと使い分け</title>
      <link>http://blog.dtdweb.com/2013/04/06/gps_desc/</link>
      <pubDate>Sat, 06 Apr 2013 03:03:02 +0000</pubDate>
      
      <guid>http://blog.dtdweb.com/2013/04/06/gps_desc/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://blog.dtdweb.com/images/wp-content/uploads/2013/04/ss1.png&#34; alt=&#34;Gps ss1&#34; title=&#34;gps_ss1.png&#34; border=&#34;0&#34; width=&#34;360&#34; height=&#34;600&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GPS機能を使ったアプリを開発する機会があったんですが、調べてみると結構複雑でして。&lt;/p&gt;

&lt;p&gt;GPSを使うにも、ネットワークから取得する方法とGPS衛星を使う方法があったりと、複数方法があったのでそれぞれの使い方と違いを書いてみました。&lt;/p&gt;

&lt;p&gt;メリット・デメリットについては若干の主観も混じっているため実際の仕様と異なる場合もございます&lt;/p&gt;

&lt;p&gt;GPSを使用したアプリサンプルについては&lt;a href=&#34;https://github.com/dtdweb/android/tree/master/GPSSample&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt;にアップしてます。&lt;/p&gt;

&lt;h2 id=&#34;gps機能の使い方とメソッド説明:426ef98a8bb738f2bde1020f7c489130&#34;&gt;GPS機能の使い方とメソッド説明&lt;/h2&gt;

&lt;p&gt;まずGPS機能を使用するにはAndroidManifest.xmlに下記のパーミッションを追加する必要があります。&lt;/p&gt;

&lt;p&gt;・GPSによる位置情報利用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;uses-permission android:name=”android.permission.ACCESS\_FINE\_LOCATION”/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;・ネットワークによる位置情報利用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;uses-permission android:name=”android.permission.ACCESS\_COARSE\_LOCATION”/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとはActivityなどで、LocationListenerインターフェースを実装し利用することが出来ます。&lt;/p&gt;

&lt;p&gt;実装が必要となるメソッドが4つあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void onLocationChanged(Location location) {
    // TODO Auto-generated method stub
}
@Override
public void onProviderDisabled(String provider) {
    // TODO Auto-generated method stub
}

@Override
public void onProviderEnabled(String provider) {
    // TODO Auto-generated method stub
}

@Override
public void onStatusChanged(String provider, int status, Bundle extras) {
    // TODO Auto-generated method stub
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし使用する上では基本的にonLocationChangedメソッドだけ使ってました。&lt;/p&gt;

&lt;p&gt;このメソッドは、位置情報が取得出来ると呼び出されるメソッドとなります。&lt;/p&gt;

&lt;h3 id=&#34;位置情報を取得してみる:426ef98a8bb738f2bde1020f7c489130&#34;&gt;位置情報を取得してみる&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ロケーションマネージャーのインスタンスを取得
LocationManager locationManager = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
// 利用できるGPSを選択してプロバイダを取得
if (locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) {
    // ネットワークプロバイダを使って検索
    locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, this);
} else if (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
    // GPSプロバイダを使って検索
    locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それぞれの引数についは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一引数：プロバイダ&lt;/li&gt;
&lt;li&gt;第二引数：通知の最小時間間隔&lt;/li&gt;
&lt;li&gt;第三引数：通知の最小距離間隔&lt;/li&gt;
&lt;li&gt;第四引数：リスナー(LocationListenerを実装した自身を渡します)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これで位置が取得できるとonLocationChangedメソッドが呼ばれますので、引数のlocationを使い緯度や経度を取得することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 緯度を取得
location.getLatitude();
// 経度を取得
location.getLongitude();
// 精度を取得
location.getAccuracy();
// 標高を取得
location.getAltitude();
// 取得時間を取得
location.getTime();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、注意点としまして、取得が終わった後やアプリを途中で終了したり、バッググラウンドに移る際は必ず位置情報の計測を停止させて下さい。&lt;/p&gt;

&lt;p&gt;停止させるまではずっと取得状態となってしまい、定期的に上記のメソッドが呼び出されてしまい、バッテリー消費の原因にもなります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;位置情報取得の終了方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;locationManager.removeUpdates(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで停止させる事ができるので、onLocationChangedやActivityのonPauseメソッド内とかでも停止させたほうが良いかと思います。&lt;/p&gt;

&lt;h2 id=&#34;各プロバイダのメリット-デメリット:426ef98a8bb738f2bde1020f7c489130&#34;&gt;各プロバイダのメリット・デメリット&lt;/h2&gt;

&lt;p&gt;若干体感や主観も混ざってしまっているのですが&lt;/p&gt;

&lt;h3 id=&#34;locationmanager-network-provider:426ef98a8bb738f2bde1020f7c489130&#34;&gt;LocationManager.NETWORK_PROVIDER&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;取得するまでの時間が早い&lt;/li&gt;
&lt;li&gt;バッテリー消費はGPS_PROVIDERより抑える事ができる&lt;/li&gt;
&lt;li&gt;GPS_PROVIDERに比べて精度が低い&lt;/li&gt;
&lt;li&gt;用途としては、ざっくりとした位置を求めるには良いのかなと思いました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;locationmanager-gps-provider:426ef98a8bb738f2bde1020f7c489130&#34;&gt;LocationManager.GPS_PROVIDER&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;取得まで時間がかかる&lt;/li&gt;
&lt;li&gt;位置情報の精度は高い&lt;/li&gt;
&lt;li&gt;室内だと場所によるが取得できない場合が多々あった&lt;/li&gt;
&lt;li&gt;現在の場所から特定の場所までの距離を計測するなど、詳細な位置を求める場合向き&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記の様な感じがしました。&lt;/p&gt;

&lt;p&gt;用途によってうまく使い分ける必要がありますね。&lt;/p&gt;

&lt;h2 id=&#34;参考:426ef98a8bb738f2bde1020f7c489130&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.android.com/reference/android/location/LocationManager.html&#34; target=&#34;_blank&#34;&gt;LocationManager | Android Developers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Android]SharedPreferencesを簡単に使うためのラッパークラスを作成してみました</title>
      <link>http://blog.dtdweb.com/2013/03/19/android-sharedpreferences/</link>
      <pubDate>Tue, 19 Mar 2013 14:40:12 +0000</pubDate>
      
      <guid>http://blog.dtdweb.com/2013/03/19/android-sharedpreferences/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://blog.dtdweb.com/images/wp-content/uploads/2013/03/SharedPreferencesApp_SS1.png&#34; alt=&#34;SharedPreferencesApp_SS1&#34; width=&#34;180&#34; height=&#34;300&#34; class=&#34;alignnone size-medium wp-image-233&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Androidのデータ永続化手法として、SQLiteやSharedPreferencesとかありますよね。&lt;/p&gt;

&lt;p&gt;自分は比較的簡単に使用することの出来るSharedPreferencesをよく使うんですが、少しでも簡単にコードをシンプルな状態で使えないかなと考え、ラッパークラスの様なものを作成してみました。&lt;/p&gt;

&lt;p&gt;ここでは、簡単な使い方の説明と紹介を載せたいと思います。&lt;/p&gt;

&lt;p&gt;まだまだAndroid開発経験が短いため、おかしな所や改善点がありましたらアドバイス等もらえるとうれしいです！…結構ToDoも残っているのですよね&amp;#8230;(笑)&lt;/p&gt;

&lt;h2 id=&#34;サンプル:964fdf811693e5a6015dc706ff70417b&#34;&gt;サンプル&lt;/h2&gt;

&lt;p&gt;テキストを保存するためのサンプルクラスはラッパークラスを継承しています。&lt;/p&gt;

&lt;p&gt;データの呼び出し・保存処理をラッパークラスで実装しているので比較的シンプルに実装できるようになっております。&lt;/p&gt;

&lt;p&gt;キーを登録して、_setや_getを呼び出し保存する仕組みです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.dtdweb.sharedpreferences.sample;

import android.content.Context;

import com.dtdweb.lib.sharedpreferences.SharedPreferencesWrapper;

public class SharedSample extends SharedPreferencesWrapper {

    private static final String TEXT_CONFIG_KEY_NAME = &amp;quot;text_config_name&amp;quot;;

    public SharedSample(Context context) {
        super(context);
    }

    /**
     * テキストの保存
     */
    public void setText(String text) {
        this._set(SharedSample.TEXT_CONFIG_KEY_NAME, text);
    }

    /**
     * 保存されているテキストデータの取得
     */
    public String getText() {
        return this._get(SharedSample.TEXT_CONFIG_KEY_NAME);
    }

    /**
     * 保存されているテキストデータを削除
     */
    public void removeText() {
        this._remove(SharedSample.TEXT_CONFIG_KEY_NAME);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity側からの呼び出し方&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SharedSample sharedSample = new SharedSample(this);
// テキストの保存
sharedSample.setText(&amp;quot;入力されたデータ&amp;quot;);
// 保存されているデータの呼び出し
String dataString = sharedSample.getText();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけで、いちいちEditorのインスタンスを作成してput***やcommitを行わずに保存・呼び出しが出来るようにしてみました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:964fdf811693e5a6015dc706ff70417b&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;そもそもこのクラスをつくろうと思ったきっかけですが、一番はやはり複数のActivityで呼び出す際にシンプルに呼び出して使えたらなと思ったのが始まりでした。&lt;/p&gt;

&lt;p&gt;他にセキュリティ的に大丈夫なのかなと思い保存の際は暗号化して保存したりと、恐らくそこまではやらなくても良かったのかもしれないですね。&lt;/p&gt;

&lt;h2 id=&#34;残っている課題点:964fdf811693e5a6015dc706ff70417b&#34;&gt;残っている課題点&lt;/h2&gt;

&lt;p&gt;現状のクラスですが、保存するデータの型がStringしか対応できておりません。&lt;/p&gt;

&lt;p&gt;数値や配列データを保存したい場合、parseしたりjson形式にしたりとで、少々不便な点も残っております。この辺は今後改善していけたらと思います！&lt;/p&gt;

&lt;p&gt;参考サイト:&lt;br /&gt;
&lt;a href=&#34;http://developer.android.com/reference/android/content/SharedPreferences.html&#34; target=&#34;_blank&#34;&gt;SharedPreferences | Android Developers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Android]WiFi接続まわりで苦戦したのでメモ</title>
      <link>http://blog.dtdweb.com/2013/03/08/android-wifi-network/</link>
      <pubDate>Fri, 08 Mar 2013 13:51:10 +0000</pubDate>
      
      <guid>http://blog.dtdweb.com/2013/03/08/android-wifi-network/</guid>
      <description>

&lt;p&gt;AndroidのWiFi設定や変更において、色々と苦戦したのでその時の記録をメモ。&lt;/p&gt;

&lt;p&gt;(*2013年3月現在 : APILevel8~16にて動作確認)&lt;/p&gt;

&lt;p&gt;こちらの記事内容で動作確認は出来ましたが、動作保証はしかねますので、使用の際には再度ドキュメントを確認した方が良いかと思います。&lt;/p&gt;

&lt;p&gt;また、端末によって微妙に挙動が異なったり、WiFi切替まで時間もかかったりと、色々と下記以外にも調整しないといけない事が多かったです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.android.com/reference/android/net/wifi/WifiManager.html&#34; target=&#34;_blank&#34;&gt;Androidリファレンス:WifiManager&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://developer.android.com/reference/android/net/wifi/WifiConfiguration.html&#34; target=&#34;_blank&#34;&gt;Androidリファレンス:WifiConfiguration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用するために:506278074be7e994baf0f209d1456c13&#34;&gt;使用するために&lt;/h2&gt;

&lt;p&gt;まずAndroidManifest.xmlに下記のパーミッション追加をする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.CHANGE\_WIFI\_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS\_WIFI\_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wifi機能をonにする:506278074be7e994baf0f209d1456c13&#34;&gt;WiFi機能をONにする&lt;/h2&gt;

&lt;p&gt;SSID登録の際は、WiFi機能が有効でないと出来ないので、もしプログラム内で有効にするには下記の方法で行う&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);
if (wifiManager.isWifiEnabled() == false) {
    wifiManager.setWifiEnabled(true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記のコードをActivityのonCreate等で実行しておくと良いかと思います。&lt;/p&gt;

&lt;p&gt;端末によっては、切り替わるまで少々時間もかかるようなんで注意も必要ですね。&lt;/p&gt;

&lt;h2 id=&#34;ssidを端末に設定する:506278074be7e994baf0f209d1456c13&#34;&gt;SSIDを端末に設定する&lt;/h2&gt;

&lt;p&gt;こちらもWiFi機能が無効の場合、正しく設定することができないので、先に有効にする処理を入れる必要があります。&lt;/p&gt;

&lt;p&gt;また、設定については認証方式毎に異なります。&lt;/p&gt;

&lt;h2 id=&#34;セキュリティなしのssidを設定する:506278074be7e994baf0f209d1456c13&#34;&gt;セキュリティなしのSSIDを設定する&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);
String ssid = &amp;quot;SSID_NAME&amp;quot;;
WifiConfiguration config = new WifiConfiguration();
config.SSID = &amp;quot;\&amp;quot;&amp;quot; + ssid + &amp;quot;\&amp;quot;&amp;quot;;
config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
config.allowedProtocols.set(WifiConfiguration.Protocol.RSN);
config.allowedProtocols.set(WifiConfiguration.Protocol.WPA);
config.allowedAuthAlgorithms.clear();
config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP40);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP104);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
int networkId = wifiManager.addNetwork(config); // 失敗した場合は-1となります
wifiManager.saveConfiguration();
wifiManager.updateNetwork(config);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;認証方式-wepのssid設定:506278074be7e994baf0f209d1456c13&#34;&gt;認証方式 : WEPのSSID設定&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);
String ssid = &amp;quot;SSID_NAME&amp;quot;;
WifiConfiguration config = new WifiConfiguration();
config.SSID = &amp;quot;\&amp;quot;&amp;quot; + ssid + &amp;quot;\&amp;quot;&amp;quot;;
config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
config.allowedProtocols.set(WifiConfiguration.Protocol.RSN);
config.allowedProtocols.set(WifiConfiguration.Protocol.WPA);
config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED);
config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP40);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP104);
config.wepKeys[0] = &amp;quot;\&amp;quot;password\&amp;quot;&amp;quot;;
config.wepTxKeyIndex = 0;
int networkId = wifiManager.addNetwork(config); // 失敗した場合は-1となります
wifiManager.saveConfiguration();
wifiManager.updateNetwork(config);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;認証方式-wpa-wpa2-pskのssid設定:506278074be7e994baf0f209d1456c13&#34;&gt;認証方式 : WPA/WPA2-PSKのSSID設定&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);
String ssid = &amp;quot;SSID_NAME&amp;quot;;
WifiConfiguration config = new WifiConfiguration();
config.SSID = &amp;quot;\&amp;quot;&amp;quot; + ssid + &amp;quot;\&amp;quot;&amp;quot;;
config.allowedProtocols.set(WifiConfiguration.Protocol.RSN);
config.allowedProtocols.set(WifiConfiguration.Protocol.WPA);
config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP40);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP104);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
config.preSharedKey = &amp;quot;\&amp;quot;password\&amp;quot;&amp;quot;;
int networkId = wifiManager.addNetwork(config); // 失敗した場合は-1となります
wifiManager.saveConfiguration();
wifiManager.updateNetwork(config);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;上記で作成したssidに接続する:506278074be7e994baf0f209d1456c13&#34;&gt;上記で作成したSSIDに接続する&lt;/h2&gt;

&lt;p&gt;networkIdが正しくとれていれば実際に接続を試してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);
int networkId = 0; // 上記設定で取得できたものを使用
String targetSSID = &amp;quot;hoge-ssid&amp;quot;;
// WiFi機能が無効の状態で呼び出されるとSSID検索の所でnullとなるので念のため例外処理を行なう
try {
    // ssidの検索を開始
    wifiManager.startScan();
    for (ScanResult result : wifiManager.getScanResults()) {
        // Android4.2以降よりダブルクォーテーションが付いてくるので除去
        String resultSSID = result.SSID.replace(&amp;quot;\&amp;quot;&amp;quot;, &amp;quot;&amp;quot;);
        if (resultSSID.equals(targetSSID)) {
            // 接続を行う
            if (networkId &amp;gt; 0) {
                // 先に既存接続先を無効にしてから接続します
                for (WifiConfiguration c0 : wifiManager.getConfiguredNetworks()) {
                    wifiManager.enableNetwork(c0.networkId, false);
                }
                wifiManager.enableNetwork(networkId, true);
            }
            break;
        }
    }
} catch (NullPointerException e) {
   // 適切な例外処理をしてください。
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでひと通りSSID設定と、接続まで出来るようになりました。&lt;/p&gt;

&lt;p&gt;接続タイミングやWiFi切替等、微妙に調整の必要があるため結構大変でした。&lt;/p&gt;

&lt;p&gt;また、認証方式毎の設定についても理解しきれていない所もあるんで、もっと勉強しないとなと思いました。&lt;/p&gt;

&lt;p&gt;詳しい方いましたら、ぜひアドバイスや間違いをご指摘頂けると嬉しいです。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>